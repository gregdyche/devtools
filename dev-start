#!/bin/bash
# dev-start: Prioritize Git status before activating Python venv
# Supports flexible venv folder names with bin/activate

set -e

# Detect if script is being sourced or executed
check_execution_mode() {
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        # Script is being executed (not sourced)
        echo "âš ï¸  Script is being executed in a subshell"
        echo "ğŸ’¡ Virtual environment activation will not persist to your shell"
        
        if [ "$NON_INTERACTIVE" = true ]; then
            echo "â­ï¸  Non-interactive mode - continuing with subshell execution..."
            return 0
        fi
        
        echo ""
        echo "Options:"
        echo "  1. Continue anyway (venv active only during script)"
        echo "  2. Exit and run: source $(realpath "${BASH_SOURCE[0]}")"
        echo "  3. Exit and run: . $(realpath "${BASH_SOURCE[0]}")"
        echo ""
        echo "Current process: $$ (parent: $PPID)"
        echo "Shell info: $0"
        echo ""
        read -p "â“ Choose (1/2/3): " -t 30 -n 1 -r
        printf "\n"
        if [ $? -ne 0 ]; then
            echo "â° Timeout - defaulting to option 1"
            REPLY="1"
        fi
        case $REPLY in
            1)
                echo "â­ï¸  Continuing with subshell execution..."
                return 0
                ;;
            2|3)
                echo "ğŸ›‘ Exiting. Please run the suggested command above."
                exit 0
                ;;
            *)
                echo "âŒ Invalid choice. Exiting."
                exit 1
                ;;
        esac
    else
        # Script is being sourced
        echo "âœ… Script is being sourced - virtual environment will persist"
        echo "Current process: $$ (parent: $PPID)"
        return 0
    fi
}

CONFIG_FILE=".dev-start.conf"
RESET_CONFIG=false
NON_INTERACTIVE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --reset)
            RESET_CONFIG=true
            shift
            ;;
        --non-interactive|-n)
            NON_INTERACTIVE=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--reset] [--non-interactive|-n]"
            exit 1
            ;;
    esac
done

print_header() {
    echo ""
    echo "=============================="
    echo "$1"
    echo "=============================="
}

load_config() {
    if [ -f "$CONFIG_FILE" ] && [ "$RESET_CONFIG" = false ]; then
        source "$CONFIG_FILE"
        return 0
    fi
    return 1
}

save_config() {
    cat > "$CONFIG_FILE" << EOF
# dev-start configuration
DIRECTORIES_CHECKED=true
SKIP_DIRS="$SKIP_DIRS"
CREATE_DIRS="$CREATE_DIRS"
PROJECT_TYPE="$PROJECT_TYPE"
SKIP_VENV_CHECK=${SKIP_VENV_CHECK:-false}
EOF
    echo "ğŸ’¾ Settings saved to $CONFIG_FILE"
}

configure_project() {
    print_header "âš™ï¸ Project Configuration"
    
    # Detect project type
    if [ -f "manage.py" ]; then
        PROJECT_TYPE="django"
    elif [ -f "package.json" ]; then
        PROJECT_TYPE="nodejs"
    elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
        PROJECT_TYPE="python"
    else
        PROJECT_TYPE="generic"
    fi
    
    echo "ğŸ“‹ Detected project type: $PROJECT_TYPE"
    
    # Ask about directories
    local dirs=("src" "tests" "docs" "examples" "scripts" "data" "config" ".github")
    local create_dirs=()
    local skip_dirs=()
    
    echo ""
    echo "ğŸ“ Configure directory structure (answer for each):"
    for dir in "${dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            echo "â“ Always create $dir/? (y/n): "
            read -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                create_dirs+=("$dir")
            else
                skip_dirs+=("$dir")
            fi
        fi
    done
    
    CREATE_DIRS=$(IFS=,; echo "${create_dirs[*]}")
    SKIP_DIRS=$(IFS=,; echo "${skip_dirs[*]}")
    
    # Ask about venv check
    echo ""
    echo "â“ Skip Python virtual environment check? (y/n): "
    read -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        SKIP_VENV_CHECK=true
    else
        SKIP_VENV_CHECK=false
    fi
    
    save_config
}

check_git_repo() {
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "âŒ Not in a Git repository"
        exit 1
    fi
    echo "ğŸ“ Project: $(basename "$(pwd)")"
}

check_git_status() {
    print_header "ğŸ“‹ Git Status"

    if [ -n "$(git status --porcelain)" ]; then
        echo "âš ï¸  Uncommitted changes:"
        git status --short
        echo ""
        echo "ğŸ”„ Recent commits:"
        git log --oneline -3
        echo ""
        read -p "â“ Continue without committing? (y/n): " -t 30 -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "ğŸ›‘ Exiting. Please commit or stash changes first."
            exit 1
        fi
    else
        echo "âœ… Working directory clean"
        local current_branch
        current_branch=$(git branch --show-current)
        echo "ğŸ“ Branch: $current_branch"

        if git fetch > /dev/null 2>&1; then
            local behind
            behind=$(git rev-list --count HEAD..origin/$current_branch 2>/dev/null || echo "0")
            if [ "$behind" -gt 0 ]; then
                echo "âš ï¸  $behind commits behind origin"
                read -p "ğŸ”„ Pull latest changes? (y/n): " -n 1 -r
                echo
                [[ $REPLY =~ ^[Yy]$ ]] && git pull
            else
                echo "âœ… Up to date with origin"
            fi
        fi
    fi
}

activate_python_venv() {
    if [ "$SKIP_VENV_CHECK" = true ]; then
        echo "â­ï¸  Skipping Python virtual environment check (configured)"
        return 0
    fi
    
    print_header "ğŸ Python Virtual Environment"
    
    VENV_PATHS=()
    for d in */; do
        [ -f "$d/bin/activate" ] && VENV_PATHS+=("$d")
    done

    if [ "${#VENV_PATHS[@]}" -eq 1 ]; then
        echo "ğŸ“¦ Found virtual environment: ${VENV_PATHS[0]%/}"
        read -p "â“ Activate this virtual environment? (y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            source "${VENV_PATHS[0]}bin/activate"
            echo "âœ… Activated: ${VENV_PATHS[0]%/}"
            echo "âœ… Python: $(which python)"
        else
            echo "â­ï¸  Skipping virtual environment activation"
        fi
    elif [ "${#VENV_PATHS[@]}" -eq 0 ]; then
        echo "âŒ No Python virtual environment found"
        read -p "â“ Create a new virtual environment? (y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Suggest name based on project
            local suggested_name="venv"
            if [ -f "manage.py" ]; then
                suggested_name="django-env"
            elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
                suggested_name="venv"
            fi
            
            echo "ğŸ’¡ Suggested name: $suggested_name"
            read -p "ğŸ“ Enter virtual environment name (or press Enter for '$suggested_name'): " venv_name
            venv_name=${venv_name:-$suggested_name}
            
            echo "ğŸ”¨ Creating virtual environment: $venv_name"
            python -m venv "$venv_name"
            
            read -p "â“ Activate the new virtual environment? (y/n): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                source "$venv_name/bin/activate"
                echo "âœ… Created and activated: $venv_name"
                echo "âœ… Python: $(which python)"
            else
                echo "âœ… Created: $venv_name (not activated)"
                echo "ğŸ’¡ To activate later: source $venv_name/bin/activate"
            fi
        else
            echo "â­ï¸  Skipping virtual environment creation"
        fi
    else
        echo "âŒ Multiple virtual environments found:"
        printf '  - %s\n' "${VENV_PATHS[@]%/}"
        echo "ğŸ› ï¸  Please keep only one venv directory in root."
        exit 1
    fi
}

analyze_project_type() {
    print_header "ğŸ” Project Analysis"
    [ -f "manage.py" ] && echo "ğŸ¯ Django project detected"
    [ -f "package.json" ] && echo "ğŸ“¦ Node.js project detected"
    [ -f "docker-compose.yml" ] || [ -f "Dockerfile" ] && echo "ğŸ³ Docker project detected"
}

check_ports() {
    print_header "ğŸ“¡ Port Check"
    for port in 3000 5000 8000 8080; do
        if lsof -i :$port > /dev/null 2>&1; then
            local proc
            proc=$(lsof -i :$port | awk 'NR==2 {print $1}')
            echo "âš ï¸  Port $port in use by $proc"
        fi
    done
}

check_env_files() {
    print_header "ğŸ” Environment Check"
    if [ -f ".env" ]; then
        echo "ğŸ”‘ .env file found"
        [ -f ".env.example" ] && echo "ğŸ“ Reference: .env.example"
    fi
}

check_project_structure() {
    if [ "$DIRECTORIES_CHECKED" != true ]; then
        return 0
    fi
    
    print_header "ğŸ“ Project Structure"
    local dirs=("src" "tests" "docs" "examples" "scripts" "data" "config" ".github")
    
    # Convert comma-separated strings to arrays
    IFS=',' read -ra CREATE_DIRS_ARRAY <<< "$CREATE_DIRS"
    IFS=',' read -ra SKIP_DIRS_ARRAY <<< "$SKIP_DIRS"
    
    # Check existing directories
    for dir in "${dirs[@]}"; do
        if [ -d "$dir" ]; then
            echo "âœ… $dir/ exists"
        fi
    done
    
    # Create configured directories
    for dir in "${CREATE_DIRS_ARRAY[@]}"; do
        if [ -n "$dir" ] && [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            echo "âœ… Created $dir/ (configured)"
            
            case "$dir" in
                "src")
                    echo "# Source code" > "$dir/README.md"
                    ;;
                "tests")
                    echo "# Tests" > "$dir/README.md"
                    ;;
                "docs")
                    echo "# Documentation" > "$dir/README.md"
                    ;;
                "examples")
                    echo "# Examples" > "$dir/README.md"
                    ;;
                "scripts")
                    echo "# Build and deployment scripts" > "$dir/README.md"
                    ;;
                "data")
                    echo "# Sample data files" > "$dir/README.md"
                    ;;
                "config")
                    echo "# Configuration files" > "$dir/README.md"
                    ;;
                ".github")
                    mkdir -p "$dir/workflows"
                    echo "# GitHub workflows and templates" > "$dir/README.md"
                    ;;
            esac
        fi
    done
    
    # Show skipped directories
    if [ -n "$SKIP_DIRS" ]; then
        echo "â­ï¸  Skipped directories (configured): $SKIP_DIRS"
    fi
}

show_tips() {
    print_header "ğŸ’¡ Helpful Commands"
    [ -f "manage.py" ] && echo "  python manage.py runserver"
    [ -f "package.json" ] && echo "  npm run dev / npm start"
    echo "  git status"
    echo "  deactivate  # Exit Python venv"
}

main() {
    echo "ğŸš€ $(date '+%Y-%m-%d %H:%M:%S') Starting dev environment in: $(pwd)"
    
    # Check execution mode first
    check_execution_mode
    echo ""
    
    # Load or create configuration
    if ! load_config || [ "$RESET_CONFIG" = true ]; then
        configure_project
        echo ""
    fi
    
    check_git_repo
    check_git_status
    activate_python_venv
    analyze_project_type
    check_project_structure
    check_ports
    check_env_files
    show_tips
    echo ""
    echo "âœ… Dev environment ready: $(pwd)"
    
    # Add .dev-start.conf to .gitignore if it doesn't exist
    if [ -f ".gitignore" ] && ! grep -q ".dev-start.conf" .gitignore; then
        echo ".dev-start.conf" >> .gitignore
        echo "ğŸ“ Added .dev-start.conf to .gitignore"
    fi
}

# Set up timeout for the entire script
if [ "$NON_INTERACTIVE" != true ]; then
    timeout 300 bash -c 'main "$@"' -- "$@" || {
        echo "â° Script timeout after 5 minutes"
        exit 1
    }
else
    main "$@"
fi